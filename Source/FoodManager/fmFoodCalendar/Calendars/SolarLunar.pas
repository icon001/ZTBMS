unit SolarLunar;

interface

uses
  Dialogs,
  SysUtils;

function SolarToLunar(ADate : TDateTime; var Y, M, D: Word; var Yun: Boolean): Boolean;
function LunarToSolar(BDate : TDateTime; Yun : Boolean; var ResultDate: TDateTime) : Boolean;
function GetExistYun(ADate : TDateTime): Boolean; 

var
  Days : array[ 0..11 ] of Byte = (31,28,31,30,31,30,31,31,30,31,30,31);
  Map : array [ 0..162, 0..12 ] of Byte =
           ({1881} (1,2,1,2,1,2,2,3,2,2,1,2,1), (1,2,1,2,1,2,1,2,2,1,2,2,0), (1,1,2,1,1,2,1,2,2,2,1,2,0), (2,1,1,2,1,3,2,1,2,2,1,2,2), (2,1,1,2,1,1,2,1,2,1,2,2,0), (2,1,2,1,2,1,1,2,1,2,1,2,0), (2,2,1,2,3,2,1,1,2,1,2,1,2), (2,1,2,2,1,2,1,1,2,1,2,1,0), (2,1,2,2,1,2,1,2,1,2,1,2,0), (1,2,3,2,1,2,2,1,2,1,2,1,2),
            {1891} (1,2,1,2,1,2,1,2,2,1,2,2,0), (1,1,2,1,1,2,3,2,2,1,2,2,2), (1,1,2,1,1,2,1,2,1,2,2,2,0), (1,2,1,2,1,1,2,1,2,1,2,2,0), (2,1,2,1,2,3,1,2,1,2,1,2,1), (2,2,2,1,2,1,1,2,1,2,1,2,0), (1,2,2,1,2,1,2,1,2,1,2,1,0), (2,1,2,3,2,2,1,2,1,2,1,2,1), (2,1,2,1,2,1,2,2,1,2,1,2,0), (1,2,1,1,2,1,2,2,3,2,2,1,2),
            {1901} (1,2,1,1,2,1,2,1,2,2,2,1,0), (2,1,2,1,1,2,1,2,1,2,2,2,0), (1,2,1,2,1,3,2,1,1,2,2,1,2), (2,2,1,2,1,1,2,1,1,2,2,1,0), (2,2,1,2,2,1,1,2,1,2,1,2,0), (1,2,2,1,4,1,2,1,2,1,2,1,2), (1,2,1,2,1,2,2,1,2,1,2,1,0), (2,1,1,2,2,1,2,1,2,2,1,2,0), (1,2,3,1,2,1,2,1,2,2,2,1,2), (1,2,1,1,2,1,2,1,2,2,2,1,0),
            {1911} (2,1,2,1,1,2,3,1,2,2,1,2,2), (2,1,2,1,1,2,1,1,2,2,1,2,0), (2,2,1,2,1,1,2,1,1,2,1,2,0), (2,2,1,2,2,3,1,2,1,2,1,1,2), (2,1,2,2,1,2,1,2,1,2,1,2,0), (1,2,1,2,1,2,2,1,2,1,2,1,0), (2,1,3,2,1,2,2,1,2,2,1,2,1), (2,1,1,2,1,2,1,2,2,2,1,2,0), (1,2,1,1,2,1,2,3,2,2,1,2,2), (1,2,1,1,2,1,1,2,2,1,2,2,0),
            {1921} (2,1,2,1,1,2,1,1,2,1,2,2,0), (2,1,2,2,1,3,2,1,1,2,1,2,2), (1,2,2,1,2,1,2,1,2,1,1,2,0), (2,1,2,1,2,2,1,2,1,2,1,1,0), (2,1,2,2,3,2,1,2,2,1,2,1,2), (1,1,2,1,2,1,2,2,1,2,2,1,0), (2,1,1,2,1,2,1,2,2,1,2,2,0), (1,2,3,1,2,1,1,2,2,1,2,2,2), (1,2,1,1,2,1,1,2,1,2,2,2,0), (1,2,2,1,1,2,3,1,2,1,2,2,1),
            {1931} (2,2,2,1,1,2,1,1,2,1,2,1,0), (2,2,2,1,2,1,2,1,1,2,1,2,0), (1,2,2,1,2,4,1,2,1,2,1,1,2), (1,2,1,2,2,1,2,2,1,2,1,2,0), (1,1,2,1,2,1,2,2,1,2,2,1,0), (2,1,1,4,1,2,1,2,1,2,2,2,1), (2,1,1,2,1,1,2,1,2,2,2,1,0), (2,2,1,1,2,1,1,4,1,2,2,1,2), (2,2,1,1,2,1,1,2,1,2,1,2,0), (2,2,1,2,1,2,1,1,2,1,2,1,0),
            {1941} (2,2,1,2,2,1,4,1,1,2,1,2,1), (2,1,2,2,1,2,2,1,2,1,1,2,0), (1,2,1,2,1,2,2,1,2,2,1,2,0), (1,1,2,1,4,1,2,1,2,2,1,2,2), (1,1,2,1,1,2,1,2,2,2,1,2,0), (2,1,1,2,1,1,2,1,2,2,1,2,0), (2,2,3,1,2,1,1,2,1,2,1,2,2), (2,1,2,1,2,1,1,2,1,2,1,2,0), (2,2,1,2,1,2,1,3,2,1,2,1,2), (2,1,2,2,1,2,1,1,2,1,2,1,0),
            {1951} (2,1,2,2,1,2,1,2,1,2,1,2,0), (1,2,1,2,1,4,2,1,2,1,2,1,2), (1,2,1,1,2,2,1,2,2,1,2,2,0), (1,1,2,1,1,2,1,2,2,1,2,2,0), (2,1,1,4,1,1,2,1,2,1,2,2,2), (1,2,1,2,1,1,2,1,2,1,2,2,0), (2,1,2,1,2,1,1,2,3,2,1,2,2), (1,2,2,1,2,1,1,2,1,2,1,2,0), (1,2,2,1,2,1,2,1,2,1,2,1,0), (2,1,2,1,2,2,3,2,1,2,1,2,1),
            {1961} (2,1,2,1,2,1,2,2,1,2,1,2,0), (1,2,1,1,2,1,2,2,1,2,2,1,0), (2,1,2,1,3,2,1,2,1,2,2,2,1), (2,1,2,1,1,2,1,2,1,2,2,2,0), (1,2,1,2,1,1,2,1,1,2,2,1,0), (2,2,2,3,2,1,1,2,1,1,2,2,1), (2,2,1,2,2,1,1,2,1,2,1,2,0), (1,2,2,1,2,1,2,3,2,1,2,1,2), (1,2,1,2,1,2,2,1,2,1,2,1,0), (2,1,1,2,2,1,2,1,2,2,1,2,0),
            {1971} (1,2,1,1,2,3,2,1,2,2,2,1,2), (1,2,1,1,2,1,2,1,2,2,2,1,0), (2,1,2,1,1,2,1,1,2,2,2,1,0), (2,2,1,2,3,1,2,1,1,2,2,1,2), (2,2,1,2,1,1,2,1,1,2,1,2,0), (2,2,1,2,1,2,1,2,3,2,1,1,2), (2,1,2,2,1,2,1,2,1,2,1,1,0), (2,2,1,2,1,2,2,1,2,1,2,1,0), (2,1,1,2,1,2,4,1,2,2,1,2,1), (2,1,1,2,1,2,1,2,2,1,2,2,0),
            {1981} (1,2,1,1,2,1,1,2,2,1,2,2,0), (2,1,2,1,3,2,1,1,2,2,1,2,2), (2,1,2,1,1,2,1,1,2,1,2,2,0), (2,1,2,2,1,1,2,1,1,2,3,2,2), (1,2,2,1,2,1,2,1,1,2,1,2,0), (1,2,2,1,2,2,1,2,1,2,1,1,0), (2,1,2,2,1,2,3,2,2,1,2,1,2), (1,1,2,1,2,1,2,2,1,2,2,1,0), (2,1,1,2,1,2,1,2,2,1,2,2,0), (1,2,1,1,2,3,1,2,1,2,2,2,2),
            {1991} (1,2,1,1,2,1,1,2,1,2,2,2,0), (1,2,2,1,1,2,1,1,2,1,2,2,0), (1,2,2,3,2,1,2,1,1,2,1,2,1), (2,2,2,1,2,1,2,1,1,2,1,2,0), (1,2,2,1,2,2,1,2,3,2,1,1,2), (1,2,1,2,2,1,2,1,2,2,1,2,0), (1,1,2,1,2,1,2,2,1,2,2,1,0), (2,1,1,2,1,3,2,2,1,2,2,2,1), (2,1,1,2,1,1,2,1,2,2,2,1,0), (2,2,1,1,2,1,1,2,1,2,2,1,0),
            {2001} (2,2,2,1,3,2,1,1,2,1,2,1,2), (2,2,1,2,1,2,1,1,2,1,2,1,0), (2,2,1,2,2,1,2,1,1,2,1,2,0), (1,2,3,2,2,1,2,1,2,2,1,1,2), (1,2,1,2,1,2,2,1,2,2,1,2,0), (1,1,2,1,2,1,2,3,2,2,1,2,2), (1,1,2,1,1,2,1,2,2,2,1,2,0), (2,1,1,2,1,1,2,1,2,2,1,2,0), (2,2,1,1,2,3,1,2,1,2,1,2,2), (2,1,2,1,2,1,1,2,1,2,1,2,0),
            {2011} (2,1,2,2,1,2,1,1,2,1,2,1,0), (2,1,2,4,2,1,2,1,1,2,1,2,1), (2,1,2,2,1,2,1,2,1,2,1,2,0), (1,2,1,2,1,2,1,2,2,3,2,1,2), (1,2,1,1,2,1,2,2,2,1,2,2,0), (1,1,2,1,1,2,1,2,2,1,2,2,0), (2,1,1,2,1,3,2,1,2,1,2,2,2), (1,2,1,2,1,1,2,1,2,1,2,2,0), (2,1,2,1,2,1,1,2,1,2,1,2,0), (2,1,2,2,3,2,1,1,2,1,2,1,2),
            {2021} (1,2,2,1,2,1,2,1,2,1,2,1,0), (2,1,2,1,2,2,1,2,1,2,1,2,0), (1,2,3,2,1,2,1,2,2,1,2,1,2), (1,2,1,1,2,1,2,2,1,2,2,1,0), (2,1,2,1,1,2,3,2,1,2,2,2,1), (2,1,2,1,1,2,1,2,1,2,2,2,0), (1,2,1,2,1,1,2,1,1,2,2,2,0), (1,2,2,1,2,3,1,2,1,1,2,2,1), (2,2,1,2,2,1,1,2,1,1,2,2,0), (1,2,1,2,2,1,2,1,2,1,2,1,0),
            {2031} (2,1,2,3,2,1,2,2,1,2,1,2,1), (2,1,1,2,1,2,2,1,2,2,1,2,0), (1,2,1,1,2,1,2,3,2,2,2,1,2), (1,2,1,1,2,1,2,1,2,2,2,1,0), (2,1,2,1,1,2,1,1,2,2,1,2,0), (2,2,1,2,1,1,4,1,1,2,1,2,2), (2,2,1,2,1,1,2,1,1,2,1,2,0), (2,2,1,2,1,2,1,2,1,1,2,1,0), (2,2,1,2,2,3,2,1,2,1,2,1,1), (2,1,2,2,1,2,2,1,2,1,2,1,0),
            {2041} (2,1,1,2,1,2,2,1,2,2,1,2,0), (1,2,3,1,2,1,2,1,2,2,2,1,2), (1,2,1,1,2,1,1,2,2,1,2,2,0) );

implementation

function SolarToLunar(ADate : TDateTime; var Y, M, D: Word; var Yun: Boolean): Boolean;
var
  AYear, AMonth, ADay, BYear, BMonth, BDay: Word;
  DT: array [0..162] of Integer;
  TD, TD0, TD1, TD2, k11, m0, m1, m2, i, j, JCount: Integer;
begin
  DeCodeDate( ADate, AYear, AMonth, ADay );
  if (AYear < 1881) or (AYear > 2043) then
   begin
     Result:= False;
     Exit;
   end;

  for i := 0 to 162 do
   begin
     DT[i] := 0;
     for j :=0 to 11 do
     case Map[i][j] of
     1,3 : DT[i] := DT[i] + 29;
     2,4 : DT[i] := DT[i] + 30;
     end;
     case Map[i][12] of
     1,3 : DT[i] := DT[i] + 29;
     2,4 : DT[i] := DT[i] + 30;
     end;
   end;

  TD1 := 1880*365 + Trunc(1880/4) - Trunc(1880/100) + Trunc(1880/400) + 30;
  k11 := (AYear-1);
  TD2 := k11*365 + Trunc(k11/4) - Trunc(k11/100) + Trunc(k11/400);
  Days[1] := 28;
  if ((AYear mod 4 = 0) and (AYear mod 100 <> 0)) or (AYear mod 400 = 0) then Days[1] := 29;
  
  for i := 0 to AMonth-2 do TD2 := TD2 + Days[i];
  TD2 := TD2 + ADay;
  TD := TD2 - TD1 + 1;

  TD0 := DT[0];
  for i := 0 to 162 do
   begin
     if TD <= TD0 then Break;
     TD0 := TD0 + DT[i+1];
   end;

  BYear := i + 1881;
  TD0 := TD0 - DT[i];
  TD  := TD - TD0;

  if Map[i][12] <> 0 then JCount := 13
                     else JCount := 12;
  m2 := 0;
  for j := 0 to JCount-1 do
   begin
     if Map[i][j] <= 2 then
      begin
        Inc(m2);
        m1 := Map[i][j] + 28;
      end
     else
        m1 := Map[i][j] + 26;
     if TD <= m1 then Break;
     TD := TD - m1;
   end;
  m0 := j;
  BMonth := m2;
  BDay := TD;

  Yun:= ( Map[BYear-1881][12] <> 0 ) and ( Map[BYear-1881][m0] > 2 );

  Y := BYear;
  M := BMonth;
  D := BDay;

  Result:= True;
end;

function LunarToSolar(BDate : TDateTime; Yun : Boolean; var ResultDate: TDateTime) : Boolean;
var
  AYear, AMonth, ADay,
  BYear, BMonth, BDay: Word;
  m1, m2, n2, i, j, r, TD: Integer;
begin
  if Yun and not GetExistYun( BDate ) then Yun:= False;

  DeCodeDate( BDate, BYear, BMonth, BDay );
  if (BYear < 1881) or (BYear > 2043) then
   begin
     Result:= False;
     Exit;
   end;

  m1 := -1;
  TD := 0;

  if BYear <> 1881 then
   begin
     m1 := BYear - 1882;
     for i := 0 to m1 do
      begin
        for j := 0 to 12 do TD := TD + Map[i][j];
        if Map[i][12]= 0 then TD := TD + 336
                         else TD := TD + 362;
      end;
  end;

  Inc(m1);
  n2 := BMonth-1;
  m2 := -1;

  r := 2;
  repeat
    Inc(m2);
    if Map[m1][m2] > 2 then
     begin
       TD := TD + 26 + Map[m1][m2];
       Inc(n2);
     end
    else
    if (m2=n2) then Break
    else TD := TD + 28 + Map[m1][m2];
  until r=1;

  if Yun then TD := TD + 28 + Map[m1][m2];
  TD := TD + BDay + 29;
  m1 := 1880;

  r := 2;
  repeat
    Inc(m1);
    m2 := 365;
    if ((m1 mod 4 = 0) and (m1 mod 100 <> 0)) or (m1 mod 400 = 0) then m2 := 366;
    if (TD < m2) then Break;
    TD := TD - m2;
  until r = 1;

  AYear := m1;
  Days[1] := m2 - 337;
  m1 := 0;

  r := 2;
  repeat
    Inc(m1);
    if (TD <= Days[m1-1]) then Break;
    TD := TD - Days[m1-1];
  until r = 1;

  AMonth := m1;
  ADay   := td;

  Days[1] := 28;
  if ((AYear mod 4 = 0) and (AYear mod 100 <> 0)) or (AYear mod 400 = 0) then Days[1] := 29;

  ResultDate := EncodeDate( AYear, AMonth, ADay );
  Result:= True;
end;

function GetExistYun(ADate : TDateTime): Boolean;
var
  AYear, AMonth, ADay: Word;
  i: Integer;
begin
  Result:= False;
  try
    DeCodeDate( ADate, AYear, AMonth, ADay );
    if Map[AYear - 1881, 12] = 0 then
     begin
       Result:= False;
       Exit;
     end
    else
     begin
       for i:= 0 to 12 do
        if Map[AYear - 1881, i] = 3 then Break;
       Result:=  i = AMonth;
     end;
  except
    Exit;
  end;
end;

end.
